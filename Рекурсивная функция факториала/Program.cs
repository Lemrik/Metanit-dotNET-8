// Рекурсивная функция представляет такую конструкцию, при которой функция вызывает саму себя.

// Возьмем, к примеру, вычисление факториала, которое использует формулу n! = 1 * 2 * … * n.
// То есть по сути для нахождения факториала числа мы перемножаем все числа до этого числа.
// Например, факториал числа 4 равен 24 = 1 * 2 * 3 * 4, а факторил числа 5 равен 120 = 1 * 2 * 3 * 4 * 5.

Console.WriteLine("\nРекурсивная функция факториала\n");

int Factorial(int n)
{
    if (n == 1) return 1;

    return n * Factorial(n - 1);
}

// При создании рекурсивной функции в ней обязательно должен быть некоторый базовый вариант,
// с которого начинается вычисление функции. В случае с факториалом это факториал числа 1, который равен 1.
// Факториалы всех остальных положительных чисел будет начинаться с вычисления факториала числа 1, который равен 1.

// На уровне языка программирования для возвращения базового варианта применяется оператор return:
// if (n == 1) return 1;

// Другая особенность рекурсивных функций: все рекурсивные вызовы должны обращаться к подфункциям,
// которые в конце концов сходятся к базовому варианту:
// eturn n * Factorial(n - 1);

int factorial4 = Factorial(4);  // 24
int factorial5 = Factorial(5);  // 120
int factorial6 = Factorial(6);  // 720

Console.WriteLine($"Факториал числа 4 = {factorial4}");
Console.WriteLine($"Факториал числа 5 = {factorial5}");
Console.WriteLine($"Факториал числа 6 = {factorial6}");


// =============== Рекурсивная функция Фибоначчи
Console.WriteLine("\nРекурсивная функция Фибоначчи\n");

// Другим распространенным показательным примером рекурсивной функции служит функция, вычисляющая числа Фибоначчи.
// n-й член последовательности Фибоначчи определяется по формуле: f(n) = f(n - 1) + f(n - 2), причем f(0)= 0, а f(1)= 1.
// То есть последовательность Фибоначчи будет выглядеть так 0 (0-й член), 1 (1-й член), 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ....
// Для определения чисел этой последовательности определим следующий метод:

int Fibonachi(int n)
{
    if (n == 0 || n == 1) return n;

    return Fibonachi(n - 1) + Fibonachi(n - 2);
}

int fib4 = Fibonachi(4);
int fib5 = Fibonachi(5);
int fib6 = Fibonachi(6);

Console.WriteLine($"4 число Фибоначчи = {fib4}");
Console.WriteLine($"5 число Фибоначчи = {fib5}");
Console.WriteLine($"6 число Фибоначчи = {fib6}");

// =============== Рекурсии и циклы
Console.WriteLine("\nРекурсии и циклы\n");

// Циклы работают быстрее и более эффективны, чем рекурсия.
static int Fibonachi2(int n)
{
    int result = 0;
    int b = 1;
    int tmp;

    for (int i = 0; i < n; i++)
    {
        tmp = result;
        result = b;
        b += tmp;
    }

    return result;
}

Console.WriteLine($"Факториал числа 4 (цикл) = {Fibonachi2(4)}");
Console.WriteLine($"Факториал числа 5 (цикл) = {Fibonachi2(5)}");
Console.WriteLine($"Факториал числа 6 (цикл) = {Fibonachi2(6)}");

// В то же время в некоторых ситуациях рекурсия предоставляет элегантное решение,
// например, при обходе различных древовидных представлений, к примеру, дерева каталогов и файлов.