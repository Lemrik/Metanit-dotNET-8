// Наиболее простой способ передачи параметров представляет передача по значению,
// по сути это обычный способ передачи параметров:

void Increment_def(int n)
{
    n++;
    Console.WriteLine($"Число в методе Increment_def: {n}");
}

int number_def = 5;
Console.WriteLine($"Число до метода Increment_def: {number_def}");
Increment_def(number_def);
Console.WriteLine($"Число после метода Increment_def: {number_def}\n");

// При передаче аргументов параметрам по значению параметр метода получает не саму переменную,
// а ее копию и далее работает с этой копией независимо от самой переменной.
// То есть изменяется копия, а сама переменная не изменяется.


Console.WriteLine("Передача параметров по ссылке и модификатор ref\n");
// ===== Передача параметров по ссылке и модификатор ref

void Increment(ref int n)
{
    n++;
    Console.WriteLine($"Число в методе Increment: {n}");
}

int number = 5;
Console.WriteLine($"Число до метода Increment: {number}");
Increment(ref number);
Console.WriteLine($"Число после метода Increment: {number}");

// При передаче значений параметрам по ссылке метод получает адрес переменной в памяти.
// И, таким образом, если в методе изменяется значение параметра, передаваемого по ссылке,
// то также изменяется и значение переменной, которая передается на его место.

// Модификатор ref указывается как перед параметром при объявлении метода,
// так и при вызове метода перед аргументом, который передается параметру


Console.WriteLine("\nref-параметры только для чтения\n");
// ===== ref-параметры только для чтения

// Начиная с версии C# 12 можно применять ref-параметры только для чтения.
// Такие параметры предваряются ключевым словом readonly: 

void Increment_readonly(ref readonly int n)
{
    // n++; // нельзя, иначе будет очишка компиляции
    Console.WriteLine($"Число в методе Increment_readonly: {n}");
}

int number_readonly = 5;
Increment_readonly(ref number_readonly);
Console.WriteLine($"Число после метода Increment_readonly: {number_readonly}");

// По сути это тоже самое, что и модификатор in,
// был введен скорее всего для поддержания старых проектов
