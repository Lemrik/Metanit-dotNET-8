/*
    Кроме обычных методов в языке C# предусмотрены специальные методы доступа, 
    которые называют свойства. Они обеспечивают простой доступ к полям классов и структур, 
    узнать их значение или выполнить их установку.


    Стандартное описание свойства имеет следующий синтаксис:

    [модификаторы] тип_свойства название_свойства
    {
        get { действия, выполняемые при получении значения свойства}
        set { действия, выполняемые при установке значения свойства}
    }

    Вначале определения свойства могут идти различные модификаторы, 
    в частности, модификаторы доступа. Затем указывается тип свойства, 
    после которого идет название свойства. Полное определение свойства содержит два блока: get и set.

    В блоке get выполняются действия по получению значения свойства. В этом блоке с помощью оператора return возвращаем некоторое значение.
    В блоке set устанавливается значение свойства. В этом блоке с помощью параметра value мы можем получить значение, которое передано свойству.

    Блоки get и set еще называются акссесорами или методами доступа (к значению свойства), а также геттером и сеттером.
 */

// см.далее класс Person
using Свойства;

Person person = new Person();

//  Устанавливаем свойство - срабатывает блок Set
//  значение "Tom" и есть передаваемое в свойство value
person.Name = "Tom";

//  Получаем значение свойства и присваиваем его переменной - срабатывает блок Get
string personName = person.Name;
Console.WriteLine(personName);  // Tom

Console.WriteLine();

//  Возможно, может возникнуть вопрос, зачем нужны свойства,
//  если мы можем в данной ситуации обходиться обычными полями класса?
//  Но свойства позволяют вложить дополнительную логику, которая может быть необходима при установке или получении значения.
//  Например, нам надо установить проверку по возрасту:

Person_second person_2 = new Person_second();

Console.WriteLine(person_2.Age);  // 1
// изменяем значение свойства
person_2.Age = 37;

Console.WriteLine(person_2.Age);  // 37
// пробуем передать недопустимое значение
person_2.Age = -23;               // Возраст должен быть в диапазоне от 1 до 120
Console.WriteLine(person_2.Age);  // 37 - возраст не изменился


//  Свойства только для чтения и записи

//  Блоки set и get не обязательно одновременно должны присутствовать в свойстве.
//  Если свойство определяет только блок get, то такое свойство доступно только для чтения - мы можем получить его значение, но не установить.

//  И, наоборот, если свойство имеет только блок set,
//  тогда это свойство доступно только для записи - можно только установить значение, но нельзя получить

Console.WriteLine("\nВычисляемые свойства:");

//  Вычисляемые свойства
//  Свойства необязательно связаны с определенной переменной.
//  Они могут вычисляться на основе различных выражений

Person_third lemrik = new ("Lemrik", "Panov");
Console.WriteLine(lemrik.Name);



Console.WriteLine();

//  Модификаторы доступа
//  Мы можем применять модификаторы доступа не только ко всему свойству, но и к отдельным блокам get и set:
//  см. класс Person_fourth

Person_fourth jam = new("Jan");


//  ==== Автоматические свойства ====

/*
    Свойства управляют доступом к полям класса. Однако что, если у нас с десяток и более полей,
    то определять каждое поле и писать для него однотипное свойство было бы утомительно. 
    Поэтому в .NET были добавлены автоматические свойства. Они имеют сокращенное объявление:

        public string Name { get; set; }
        public int Age { get; set; }

    На самом деле тут также создаются поля для свойств, только их создает не программист в коде, 
    а компилятор автоматически генерирует при компиляции.

    В чем преимущество автосвойств, если по сути они просто обращаются к автоматически создаваемой переменной, 
    почему бы напрямую не обратиться к переменной без автосвойств? 
    Дело в том, что в любой момент времени при необходимости мы можем развернуть автосвойство в обычное свойство, 
    добавить в него какую-то определенную логику.

    Стоит учитывать, что нельзя создать автоматическое свойство только для записи, как в случае со стандартными свойствами.

    Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств):
        
        public string Name { get; set; } = "Tom";
        public int Age { get; set; } = 37;

    И если мы не укажем для объекта Person значения свойств Name и Age, то будут действовать значения по умолчанию.

    Автосвойства также могут иметь модификаторы доступа:

        public string Name { private set; get;}

    Мы можем убрать блок set и сделать автосвойство доступным только для чтения. 
    В этом случае для хранения значения этого свойства для него неявно будет создаваться поле с модификатором readonly, 
    поэтому следует учитывать, что подобные get-свойства можно установить либо из конструктора класса, либо при инициализации свойства
 */

/*
    Блок init

    Начиная с версии C# 9.0 сеттеры в свойствах могут определяться с помощью оператора init 
    (от слова "инициализация" - это есть блок init призван инициализировать свойство). 

    Для установки значений свойств с init можно использовать только инициализатор, либо конструктор,
    либо при объявлении указать для него значение.
    
    После инициализации значений подобных свойств их значения изменить нельзя - они доступны только для чтения.
    В этом плане init-свойства сближаются со свойствами для чтения. 
    Разница состоит в том, что init-свойства мы также можем установить в инициализаторе
    (свойства для чтения установить в инициализаторе нельзя)

        Person person = new();
        person.Name = "Bob";    //! Ошибка - после инициализации изменить значение нельзя
 
        Console.WriteLine(person.Name); // Undefined
        public class Person
        {
            public string Name { get; init; } = "Undefined";
        }

    
 */

//  ==== модификатор required ====

//  Модификатор required(добавлен в C# 11) указывает,
//  что поле или свойства с этим модификатором обязательно должны быть инициализированы.

//  public required string Name { get; set; }
//  public required int Age { get; set; }