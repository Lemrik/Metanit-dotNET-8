//  Кроме стандартных значений типа чисел, строк, язык C# имеет специальное значение - null,
//  которое фактически указывает на отсутствие значения как такового, отсутствие данных.
//  До сих пор значение null выступает как значение по умолчанию для ссылочных типов.

//  До версии C# 8.0 всем ссылочным типам спокойно можно было присваивать значение null

//  Но начиная с версии C# 8.0 в язык была введена концепция ссылочных nullable-типов (nullable reference types)
//  и nullable aware context - nullable-контекст, в котором можно использовать ссылочные nullable-типы.



//  Чтобы определить переменную/параметр ссылочного типа, как переменную/параметр,
//  которым можно присваивать значение null, после названия типа указывается знак вопроса ?

using System;

string? name = null;
Console.WriteLine(name);    // ничего не выведет

Console.WriteLine();

//  К примеру встроенный метод Console.ReadLine(). который считывает с консоли строку,
//  возвращает именно значение string?, а не просто string

string? lastname = Console.ReadLine();

//  Зачем нужно это значение null? В различных ситуациях бывает удобно, чтобы объекты могли принимать значение null,
//  то есть были бы не определены. Стандартный пример - работа с базой данных, которая может содержать значения null.
//  И мы можем заранее не знать, что мы получим из базы данных - какое-то определенное значение или же null.

//  При этом подобные ссылочные типы, которые допускают присвоение значения null,
//  доступно только в nullable-контексте. Для nullable-контекста характерны следующие особенности:

//      Переменную ссылочного типа следует инициализировать конкретным значением, ей не следует присваивать значение null

//      Переменной ссылочного nullable-типа можно присвоить значение null,
//      но перед использование необходимо проверять ее на значение null.


// =============================================================================================================================


//  nullable - контекст - это опция, которой мы можем управлять.
//      в файле проекта строка <Nullable>enable</Nullable> для отключения disable

//  элемент<Nullable> со значением enable указывает, что эта nullable-контекст будет распространяться на весь проект.

//  Мы также можем включить nullable-контекст на урове отдельных участков кода с помощью директивы #nullable enable. 
//          #nullable enable // включаем nullable-контекст на уровне файла
//          #nullable disable // отключаем nullable-контекст на уровне файла

#nullable disable
string text = null; // здесь nullable-контекст не действует
#nullable restore
//  Любой код между директивами #nullable disable и #nullable restore будет исключен из nullable-контекста и тем самым не будет подлежать статическому анализу.


// =============================================================================================================================


//  Чем так плох null? Дело в том, что это значение означает, отсутствие данных.
//  Но, допустим, у нас есть ситуация, когда мы получаем извне некоторую строку и пытаемся обратиться к ее функциональности.
//  Например, в примере ниже у строки вызывается метод ToUpper(), который переводит все символы строки в верхний регистр:

string lol = null;
PrintUpper(lol);  // ! NullReferenceException

void PrintUpper(string text)
{
    Console.WriteLine(text.ToUpper());
}

//  Здесь при выполнении вызова PrintUpper(name) мы столкнемся с исключением NullReferenceException,
//  и программа аварийно завершит свою работу.

//  Кто-то может сказать, что ситуация искуственная - мы же явно знаем, что в функцию передается null.
//  Однако в реальности данные могут приходить извне, например, из базы данных, откуда-то из сети и т.д.
//  И мы можем явно не знать, есть ли в реальности данные или нет.

//  И использование ссылочных nullable-типов позволяет частично решить эту ситуацию.
//  Частично - поскольку предупреждения все равно не мешают нам скомпилировать и запустить программу выше.
//  Однако nullable-контекст позволяет воспользоваться возможностями статического анализа,
//  благодаря которому можно увидеть потенциально опасные куски кода, где мы можем столкнуться с NullReferenceException.


//  Оператор!(null - forgiving operator) ================================

//  Оператор!(null - forgiving operator) позволяет указать, что переменная ссылочного типа не равна null:

//  Здесь если бы мы не использовали оператор !, а написали бы PrintUpper(name),
//  то компилятор высветил бы нам предупреждение.
//  чтобы убрать ненужное предупреждение, применяется данный оператор.
//  То есть данный оператор не оказывает никакого влияния во время выполнения кода и предназначен только для статического анализа компилятора.
//  Во время выполнения выражение name! будет аналогично значению name