//  Доступ к членам базового класса из класса-наследника


//  Вернемся к нашим классам Person и Employee.
//  Хотя Employee наследует весь функционал от класса Person, посмотрим, что будет в следующем случае:

/*
        class Employee : Person
        {
            public void PrintName()
            {
                Console.WriteLine(Name);
            }
        }
*/

//  Этот код не сработает и выдаст ошибку, так как переменная _name объявлена с модификатором private
//  и поэтому к ней доступ имеет только класс Person.
//  Но зато в классе Person определено общедоступное свойство Name, которое мы можем использовать (см. класс Employee)

//  Таким образом, производный класс может иметь доступ только к тем членам базового класса,
//  которые определены с модификаторами private protected (если базовый и производный класс находятся в одной сборке),

//  public, internal (если базовый и производный класс находятся в одной сборке), protected и protected internal.


//  Конструкторы в производных классах ============================

//  Конструкторы не передаются производному классу при наследовании.
//  И если в базовом классе не определен конструктор по умолчанию без параметров,
//  а только конструкторы с параметрами (как в случае с базовым классом Person2),
//  то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base.
//
//  Например, из класса Employee уберем определение конструктора:

/*
        class Employee : Person
        {
            public string Company { get; set; } = "";
        }
 */

//  В данном случае мы получим ошибку, так как класс Employee не соответствует классу Person,
//  а именно не вызывает конструктор базового класса. Даже если бы мы добавили какой-нибудь конструктор,
//  который бы устанавливал все те же свойства, то мы все равно бы получили ошибку:

/*
        class Employee : Person
        {
            public string Company { get; set; } = "";
            public Employee(string name, string company)    // ! Ошибка
            {
                Name = name;
                Company = company;
            }
        }
 */

//  То есть в классе Employee через ключевое слово base надо явным образом вызвать конструктор класса Person:

/*
        class Employee : Person
        {
            public string Company { get; set; } = "";
            public Employee(string name, string company)
                : base(name)
            {
                Company = company;
            }
        }
 */

//  Либо в качестве альтернативы мы могли бы определить в базовом классе конструктор без параметров:

/*
        class Person
        {
            public string Name { get; set; }
            // конструктор без параметров
            public Person()
            {
                Name = "Tom";
                Console.WriteLine("Вызов конструктора без параметров");
            }
            public Person(string name)
            {
                Name = name;
            }
            public void Print()
            {
                Console.WriteLine(Name);
            }
        }
 */

//  Тогда в любом конструкторе производного класса, где нет обращения конструктору базового класса,
//  все равно неявно вызывался бы этот конструктор по умолчанию. Например, следующий конструктор

/*
        public Employee(string company)
        {
            Company = company;
        }
 */

//  Фактически был бы эквивалентен следующему конструктору:

/*
        public Employee(string company)
            :base()
        {
            Company = company;
        } 
*/

//  Порядок вызова конструкторов
//  При вызове конструктора класса сначала отрабатывают конструкторы базовых классов и только затем конструкторы производных







