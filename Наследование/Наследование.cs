//  Наследование(inheritance) является одним из ключевых моментов ООП.
//  Благодаря наследованию один класс может унаследовать функциональность другого класса.

//  Пусть у нас есть следующий класс Person, который описывает отдельного человека:

// см. класс Person

//  Но вдруг нам потребовался класс, описывающий сотрудника предприятия - класс Employee.
//  Поскольку этот класс будет реализовывать тот же функционал, что и класс Person, так как сотрудник - это также и человек,
//  то было бы рационально сделать класс Employee производным (или наследником, или подклассом) от класса Person,
//  который, в свою очередь, называется базовым классом или родителем (или суперклассом):

//  см. класс Employee
/* 
    internal class Employee : Person
    {

    }
*/

//  После двоеточия мы указываем базовый класс для данного класса.
//  Для класса Employee базовым является Person, и поэтому класс Employee наследует все те же свойства, методы, поля, которые есть в классе Person.
//  Единственное, что не передается при наследовании, это конструкторы базового класса с параметрами.

//  Таким образом, наследование реализует отношение is-a (является),
//  объект класса Employee также является объектом класса Person:

using Наследование;

Person person = new Person { Name = "Tom" };
person.Print();   // Tom
person = new Employee { Name = "Sam" };
person.Print();   // Sam

//  И поскольку объект Employee является также и объектом Person,
//  то мы можем так определить переменную: Person p = new Employee().

//  По умолчанию все классы наследуются от базового класса Object,
//  даже если мы явным образом не устанавливаем наследование.
//  Поэтому выше определенные классы Person и Employee кроме своих собственных методов,
//  также будут иметь и методы класса Object: ToString(), Equals(), GetHashCode() и GetType().


//  Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:

//  Не поддерживается множественное наследование, класс может наследоваться только от одного класса.

//  При создании производного класса надо учитывать тип доступа к базовому классу -
//  тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим.
//  То есть, если базовый класс у нас имеет тип доступа internal,
//  то производный класс может иметь тип доступа internal или private, но не public.

//  Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах),
//  то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.

//  Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы.
//  Например, следующий класс не допускает создание наследников:

sealed class Admin
{
}

